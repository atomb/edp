{-# LANGUAGE TypeSynonymInstances #-}
{-# LANGUAGE FlexibleInstances #-}
{-# OPTIONS_GHC -fno-warn-orphans #-}
module TreeTerm where

import Data.List (isPrefixOf, intercalate)
import Data.List.Split (splitOn)
import Data.Tree
import Data.Tree.Zipper hiding (last)
import Text.Read (readMaybe)

import Utils

------------------
-- Basic Term Type
------------------

type Term a = Tree [a]

instance (Ord a) => Ord (Tree a) where
  compare (Node as ts) (Node as' ts') = compare (as, ts) (as', ts')

instance Monoid (Term a) where
  mempty = Node [] []
  mappend (Node as ns) (Node as' ns') = Node (as ++ as') (ns ++ ns')

atom :: a -> Term a
atom a = Node [a] []

true :: Term a
true = mempty

false :: Term a
false = tnot true

tnot :: Term a -> Term a
tnot t = Node [] [t]

tand :: Term a -> Term a -> Term a
tand = mappend

tor :: Term a -> Term a -> Term a
tor t t' = tnot (tand (tnot t) (tnot t'))

timp :: Term a -> Term a -> Term a
--timp t t' = tor (tnot t) t' -- This produces less recognizable formulas.
timp t t' = tnot (tand t (tnot t'))

----------------------
-- End Basic Term Type
----------------------


------------------
-- Double Negation
------------------

------------------------------------------------------------------------
-- The rule for eliminating double negation in a Term:
--
-- If a child of an enclosing term has no atoms and has a single child
-- of its own, that second child's contents can be merged into the
-- enclosing term.
------------------------------------------------------------------------

-- | Does the given term have a child node representing a double
-- negation?
hasDoubleNeg :: Term a -> Bool
hasDoubleNeg (Node _ ts) = any isNeg ts
  where isNeg (Node [] [_]) = True
        isNeg _ = False

-- | Does the given child of the given term represent a double
-- negation?
isDoubleNeg :: Term a -> Int -> Bool
isDoubleNeg (Node _ ts) n =
  case safeIndex n ts of
    Just (Node [] [_]) -> True
    _ -> False

-- | Add a double negative to the top level of a term.
addDoubleNeg :: Term a -> Term a
addDoubleNeg = tnot . tnot

-- | Remove a negation from the top level of a term, if one exists.
removeNeg :: Term a -> Maybe (Term a)
removeNeg (Node [] [t]) = Just t
removeNeg _ = Nothing

----------------------
-- End Double Negation
----------------------


------------
-- Positions
------------
data Pos = Pos { indices :: [Int] }
  deriving (Eq, Ord, Show)

data AtomPos = AtomPos { aPos :: Pos, aIdx :: Int }
  deriving (Eq, Ord, Show)

-- | Indicates the polarity of the child at the given position,
-- assuming the position is a path from the root of a tree (i.e., the
-- positive space of the overall paper). Positive polarity is @True@,
-- and negative polarity is @False@.
posPolarity :: Pos -> Bool
posPolarity = even . length . indices

-- | Indicates whether the term at the first position encloses the
-- term at the second position. True of the two positions are equal,
-- as well.
encloses :: Pos -> Pos -> Bool
encloses (Pos is) (Pos is') = isPrefixOf is is'

-- | Get the position of the parent of the given position.
parentPos :: Pos -> Maybe Pos
parentPos (Pos []) = Nothing
parentPos (Pos is) = Just (Pos (init is))

-- | Convert a term position into a string that's widely transportable
-- (e.g., usable in HTTP URLS).
showPos :: Pos -> String
showPos (Pos is) = 'p' : intercalate "_" (map show is)

-- | Convert an atom position into a string that's widely
-- transportable (e.g., usable in HTTP URLS).
showAtomPos :: AtomPos -> String
showAtomPos p = showPos (aPos p) ++ "__" ++ show (aIdx p)

-- | Invert term position strings generated by @showPos@.
parsePos :: String -> Maybe Pos
parsePos "p" = Just (Pos [])
parsePos ('p':s) = Pos <$> mapM readMaybe (splitOn "_" s)
parsePos _ = Nothing

-- | Invert atom position strings generated by @showAtomPos@.
parseAtomPos :: String -> Maybe AtomPos
parseAtomPos s =
  case splitOn "__" s of
    [p, a] -> AtomPos <$> parsePos p <*> readMaybe a
    _ -> Nothing

-- | Append a single additional index to the end of a path.
--
-- This will unfortunately lead to quadratic time if we use it to form
-- a path piece by piece. Let's fix that eventually.
posExtend :: Pos -> Int -> Pos
posExtend (Pos is) i = Pos (is ++ [i])

----------------
-- End Positions
----------------


-----------------
-- Tree Utilities
-----------------

type TermPosF a = TreePos Full [a]

-- | Add a child at a given @TreePos@, yilding a full @Tree@.
addChild :: Tree a -> TreePos Full a -> Tree a
addChild c = toTree . insert c . children

-- | Get the enclosing @Tree@ of an empty @TreePos@, if any.
topE :: TreePos Empty a -> Maybe (Tree a)
topE p = toTree <$> parent p

-- | Generalization of @modifyLabel@ from @Data.Tree.Zipper@.
modifyLabelM :: (Functor m, Applicative m) =>
                (a -> m a) -> TreePos Full a -> m (TreePos Full a)
modifyLabelM f p = setLabel <$> f (label p) <*> pure p

---------------------
-- End Tree Utilities
---------------------


--------------------------
-- Zipper-based Traversals
--------------------------

-- | Create the zipper formed by navigating from the given @TreePos@ to
-- the given position.
navigate' :: Pos -> (TermPosF a) -> Maybe (TermPosF a)
navigate' (Pos [])     t = Just t
navigate' (Pos (i:is)) t = navigate' (Pos is) =<< childAt i t

-- | Create the zipper formed by navigating in the given @Term@ to the
-- given position.
navigate :: Pos -> Term a -> Maybe (TermPosF a)
navigate p = navigate' p . fromTree

-- | Apply a function on @TermPosF@ at a particular position within a
-- term.
atPos :: Pos -> (TermPosF a -> TermPosF a) -> Term a -> Maybe (Term a)
atPos p f t = (toTree . f) <$> navigate p t

-- | Apply a partial function on @TermPosF@ at a particular position
-- within a term.
atPosM :: Pos -> (TermPosF a -> Maybe (TermPosF a)) -> Term a
       -> Maybe (Term a)
atPosM p f t = toTree <$> (f =<< navigate p t)

-- | Get the subterm at the given position.
getSubterm :: Pos -> Term a -> Maybe (Term a)
getSubterm p t = tree <$> navigate p t

-- | Get the atom at the given atom position.
getAtom :: AtomPos -> Term a -> Maybe a
getAtom p t = (safeIndex (aIdx p) . label) =<< navigate (aPos p) t

-- | Insert a subterm within a given term.
insertIn :: Pos -> Term a -> Term a -> Maybe (Term a)
insertIn p c t = addChild c <$> navigate p t

-- | Insert a subterm alongside a given subterm.
insertBy :: Pos -> Term a -> Term a -> Maybe (Term a)
insertBy p t t' = do
  p' <- parentPos p
  insertIn p' t t'

-- | Insert a subterm alongside a given atom.
insertByAtom :: AtomPos -> Term a -> Term a -> Maybe (Term a)
insertByAtom p = insertIn (aPos p)

-- | Insert an atom within the tree node indicated by the given position.
insertAtom :: Pos -> a -> Term a -> Maybe (Term a)
insertAtom p a = atPos p (modifyLabel (a:))

-- | Delete the subterm at the given position. TODO: Should there be a
-- special case where deleting the entire tree yields @true@?
deleteSubterm :: Pos -> Term a -> Maybe (Term a)
deleteSubterm p t = topE =<< (delete <$> navigate p t)

-- | Delete the atom at the given atom position.
deleteAtom :: AtomPos -> Term a -> Maybe (Term a)
deleteAtom p = atPosM (aPos p) (modifyLabelM (remove (aIdx p)))

-- | Copy the atom at the first position into the term at the second
-- position.
copyAtom :: AtomPos -> Pos -> Term a -> Maybe (Term a)
copyAtom apos p t = do
  a <- getAtom apos t
  insertAtom p a t

-- | Copy the subterm at the first position as a new child of the
-- subterm at the second position.
copySubterm :: Pos -> Pos -> Term a -> Maybe (Term a)
copySubterm p p' t = do
  t' <- getSubterm p t
  insertIn p' t' t

-- | Duplicate the subterm at the given position (alongside the
-- original).
dupSubterm :: Pos -> Term a -> Maybe (Term a)
dupSubterm p t = do
  p' <- parentPos p
  copySubterm p p' t

-- | Duplicate the atom at the given position (alongside the
-- original).
dupAtom :: AtomPos -> Term a -> Maybe (Term a)
dupAtom pos@(AtomPos p _) = copyAtom pos p

-- | Insert a double negation around the node at the given position.
-- (Rule 3i, which is always legal)
insertDoubleNeg :: Pos -> Term a -> Maybe (Term a)
insertDoubleNeg p = atPos p (modifyTree addDoubleNeg)

-- | Delete the double negation at the given position (if there is
-- one). (Rule 3e, which is always legal).
--
-- Given the position of the child node that is the double negation,
-- this extracts that child, deletes it from the tree, removes its
-- extra negation, and merges it with the parent of the given
-- position.
deleteDoubleNeg :: Pos -> Term a -> Maybe (Term a)
deleteDoubleNeg p t = do
  p' <- parentPos p
  c <- removeNeg =<< getSubterm p t
  t' <- deleteSubterm p t
  atPos p' (modifyTree (tand c)) t'

-- | Is the node at the given position a child that, in its current
-- context, is doubly negated?
isDoubleNegAtPos :: Pos -> Term a -> Maybe Bool
isDoubleNegAtPos p t = do
  p' <- parentPos p
  t' <- getSubterm p' t
  return (isDoubleNeg t' (last (indices p)))

------------------------------
-- End Zipper-based Traversals
------------------------------

--------
-- Rules
--------

-- When are insertions and deletions allowed?

-- | Is it legal to insert an arbitrary subterm at a specific
-- position? Only if the position refers to a negative (shaded) node.
-- (Rule 1i)
insertAllowed :: Pos -> Bool
insertAllowed = not . posPolarity

-- | Is it legal to insert an arbitrary atom at a specific position?
-- Only if the position refers to a negative (shaded) node. (Rule 1i)
insertAtomAllowed :: AtomPos -> Bool
insertAtomAllowed = not . posPolarity . aPos

-- | Is it legal to delete an arbitrary subterm at the given position?
-- Only if the position refers to a positive (unshaded) node, or if
-- the node exists higher in the tree. (Rule 1e, Rule 2e)
deleteAllowed :: (Eq a) => Pos -> Term a -> Bool
deleteAllowed p t = posPolarity p || findTermAbove t p

-- | Is it legal to delete an arbitary atom at the given position?
-- Only if the position refers to a positive (shaded) node, or if the
-- atom exists higher in the tree. (Rule 1e, Rule 2e)
deleteAtomAllowed :: (Eq a) => AtomPos -> Term a -> Bool
deleteAtomAllowed p t = posPolarity (aPos p) || findAtomAbove t p

-- | Is it legal to copy a subterm from the first position into the
-- term indicated by the second? Only if the first position encloses
-- of the second. (Rule 2i) TODO: should it be the parent of the first
-- term, to allow side-by-side duplication?
copyAllowed :: Pos -> Pos -> Bool
copyAllowed p p' = p `encloses` p'

-- | Is it legal to copy an atom from the first position into the term
-- indicated by the second position? Only if the term containing the
-- atom encloses the second term. (Rule 2i)
copyAtomAllowed :: AtomPos -> Pos -> Bool
copyAtomAllowed p p' = aPos p `encloses` p'

{-
-- | Is it legal to delete the term at the second position relative to
-- a copy at the first position? Only if the terms at the two
-- positions are equal and the first position encloses the second.
-- (Rule 2e)
deleteCopyAllowed :: (Eq a) => Term a -> Pos -> Pos -> Bool
deleteCopyAllowed t p p' = mequal == Just True
  where
    mequal = do
      st <- getSubterm p t
      st' <- getSubterm p' t
      return (st == st' && encloses p p')

-- | Is it legal to delete the atom at the second position relative to
-- a copy at the first position? Only if the atoms at the two
-- positions are equal and the first position encloses the second.
-- (Rule 2e)
deleteAtomCopyAllowed :: (Eq a) => Term a -> AtomPos -> AtomPos -> Bool
deleteAtomCopyAllowed t p p' = mequal == Just True
  where
    mequal = do
      a <- getAtom p t
      a' <- getAtom p' t
      return (a == a' && encloses (aPos p) (aPos p'))
-}

------------
-- End Rules
------------

--------------------------
-- Alternative Term Search
--------------------------

-- | Alternative way to determine whether an atom can be deleted.
findAtomAbove :: (Eq a) => Term a -> AtomPos -> Bool
findAtomAbove t p = mfound == Just True
  where mfound = do
          tf <- navigate (aPos p) t
          let as = label tf
          a <- safeIndex (aIdx p) as
          as' <- remove (aIdx p) as
          return (elem a as' || maybe False (findA a) (parent tf))
        findA a tf = elem a (label tf) ||
                     maybe False (findA a) (parent tf)

-- | Alternative way to determine whether a term can be deleted.
findTermAbove :: (Eq a) => Term a -> Pos -> Bool
findTermAbove t p = mfound == Just True
  where mfound = do
          c <- getSubterm p t
          tf <- navigate p t
          return (findT c tf)
        findT c tf =
           elem c (before tf) ||
           elem c (after tf) ||
           maybe False (findT c) (parent tf)

------------------------------
-- End Alternative Term Search
------------------------------
